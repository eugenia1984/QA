# :star2: 1.2 - Ciclo de desarrollo de software I 

---

### M√≥dulo 1 / Encuentro 2/17

---

![image](https://user-images.githubusercontent.com/72580574/214074036-3125f667-28ea-4ab5-823a-b8ca8c6e4f11.png)

---

## :star: INTRODUCCI√ìN Y ROMPEHIELO


![image](https://user-images.githubusercontent.com/72580574/214074127-436bb9a3-675a-4371-8506-09d1781f21d7.png)

**¬°Te damos la bienvenida a tu segundo encuentro de trabajo!**

Esperamos que hayas tenido un excelente equipo en tu primera sesi√≥n. Hoy conocer√°s a un equipo nuevo. Recuerda reconocer con un pulso a aquellos integrantes que hoy colaboren m√°s con tu aprendizaje. Y si valoras al equipo completo, ¬°no dudes en entregarle un pulso al equipo completo! As√≠ te estar√°s asegurando que nuestro algoritmo te asigne en los pr√≥ximos encuentros con personas que colaboren con tu aprendizaje.

**¬°Demos comienzo a la actividad del d√≠a de hoy!**

### <img src="https://img.icons8.com/ios/50/null/people-working-together.png"/>  PRESENTACI√ìN DEL EQUIPO:

No dejes de hacer la peque√±a ceremonia de presentaci√≥n. Toma tan solo unos minutos y cambia la experiencia de todo el equipo. Indica tu nombre y de d√≥nde vienes. Ya sabes: puedes hacerlo en el chat si no deseas romper el hielo t√∫ primero.

Les dejamos una pregunta para abrir la sesi√≥n (si lo desean):

¬øTienen alguna experiencia con programaci√≥n? 

¬øSaben por qu√© es relevante saber algo de programaci√≥n para dedicarse al testing?

Utilicen unos 10 minutos para compartir estas breves presentaciones. 

¬°An√≠mate! Quienes est√°n contigo en el equipo de hoy son parte de la gran comunidad que est√° aprendiendo junto a t√≠.


---

## <img src="https://img.icons8.com/emoji/48/null/writing-hand.png"/> MANOS A LA OBRA

![image](https://user-images.githubusercontent.com/72580574/214074404-a2d33ca9-7859-436e-a1c0-7ba0566ed504.png)

Hoy vamos a tomar un peque√±o desv√≠o por el mundo de la creaci√≥n de software. Para ello, estaremos utilizando **Scratch** que ser√° necesario para resolver las actividades del encuentro de hoy.

**Secreto de la industria**: 

Scratch fue creado por el MIT Media Lab, uno de los centros de innovaci√≥n tecnol√≥gica m√°s prestigiosos del mundo. Lleva 15 a√±os cumpliendo su misi√≥n de que ni√±os y j√≥venes de todo el mundo den sus primeros pasos en el mundo de la programaci√≥n. Scratch es completamente gratuito, es usado por millones de personas en todo el mundo y es enga√±osamente simple.

Parece un juego para ni√±os, pero varios de sus desaf√≠os son dif√≠ciles de resolver hasta para programadores senior, ya que el desaf√≠o est√° en la l√≥gica de c√≥mo pensar el programa y no tanto en la resoluci√≥n ya que Scratch funciona a base de im√°genes y no c√≥digo de texto.

![image](https://user-images.githubusercontent.com/72580574/214074700-56983d6d-dfee-4c1a-8464-ba91a424735c.png)


Tendr√°s que realizar 3 actividades que ser√°n cada vez m√°s complejas.

**¬øLas realizo en equipo o en forma individual?**

Esto es lo que nosotros sugerimos: que comiences en forma individual para poder detectar esas partes que te salen m√°s f√°cil y esas partes que te cuestan m√°s.

Pueden acordar como equipo destinar, por ejemplo, unos 20 min a entender la ejercitaci√≥n e intentar resolverla en forma individual y luego dedicar unos 25 minutos a resolver punto por punto en equipo, apoy√°ndose en las fortalezas que traiga cada integrante del equipo de hoy.

¬øTe interesa ahondar un poco m√°s en los conceptos de la programaci√≥n? Aqu√≠ te dejamos un Anexo con algunas definiciones. Recuerda que este es material extra, su lectura no est√° contemplada en el desarrollo de la jornada.

---

:computer: -> [BASES DE LA PROGRAMACION](https://docs.google.com/document/d/1P51kCox48lHC13M__HAKENGVY9Akgvfn/edit?usp=sharing&ouid=100957054197686802986&rtpof=true&sd=true), al final de esta gu√≠a est√° toda la teor√≠a detallada.


---

## ‚ñ∂Ô∏è EJERCICIO #1

- Accede a Scratch - [https://scratch.mit.edu/](https://scratch.mit.edu/)

Nota: no es necesario crearte un usuario, puedes ir directo a la secci√≥n "CREAR"

![image](https://user-images.githubusercontent.com/72580574/214075195-6ce37195-a736-4c52-bf72-815230a8ceff.png)


- **Descripci√≥n del desaf√≠o general**: Lograr que el personaje realice una serie de acciones que le indicamos. Para ello debemos generar una lista de comandos para que el personaje realice acciones precisas.

- A - Que se desplace de izquierda a derecha unos 30 pasos y pregunte tu nombre.

- B - Que repita la acci√≥n anterior 6 veces y se detenga por si solo.


¬øLo has logrado? No dejes de ver los tutoriales de Scratch, ya que son breves y muy claros.

¬øPara qu√© estamos haciendo este ejercicio? 

Lo que estamos resolviendo son algoritmos muy b√°sicos. Esto nos permite comprender c√≥mo est√° hecho el c√≥digo en un programa o software. Y luego como testers tendremos la posibilidad de identificar mejor en d√≥nde es que esta serie de instrucciones est√° fallando. Podremos ser m√°s precisos y efectivos, entregando informes muy valiosos para mejorar el producto para el que estemos trabajando.

**Un algoritmo es una serie de gu√≠as que describen c√≥mo realizar una tarea. Piensa en un algoritmo como una serie de instrucciones paso a paso que crean un patr√≥n predecible en una serie de n√∫meros o unas l√≠neas de c√≥digo.**

## ‚ñ∂Ô∏è EJERCICIO #2

- A - Lograr que el gatito d√© 3 vueltas alrededor de la pantalla. ¬øNo sabes c√≥mo deber√≠a lucir? Aqu√≠ tienes un [link](https://scratch.mit.edu/projects/556056325/) a una muestra del resultado final esperado.

- B - Accede a este [link](https://scratch.mit.edu/projects/556059221/editor/). Analiza el c√≥digo y realiza los siguientes cambios:

-b.1. Cambia el gatito por un personaje que te represente a ti.

-b.2. Cambia el obst√°culo por uno m√°s realista.

-b.3. Cambia el texto de lo que dice el personaje por un texto que desees o consideres apropiado para compartir con el equipo de hoy.


## ‚ñ∂Ô∏è EJERCICIO #3 - DESAF√çO OFICIAL DE SCRATCH

[https://scratch.mit.edu/projects/114805446/](https://scratch.mit.edu/projects/114805446/)

¬øTe animas a replicar lo que ves en pantalla?

Tienes dos caminos posibles:

->>>> Camino A, para quienes ya tienen algo de experiencia en escribir c√≥digo

- **DISE√ëO**: Escribir lo que te parece que debes realizar, armar un peque√±o diagrama de los pasos a realizar. Documentar ese diagrama (no solamente hacerlo en forma mental).

- **EJECUCI√ìN**: Correr el programa y cotejar contra el ejemplo si ha fallado algo en el dise√±o inicial. Documentar los cambios que realices para ajustar.

- **DOCUMENTACI√ìN FINAL**: Escribe el flujo en un diagrama y luego muestra en pantalla c√≥mo funciona tu versi√≥n. Puedes hacer mejoras est√©ticas, de personajes, pero no funcionales.

->>>> Camino B, para quienes hoy est√°n probando escribir c√≥digo por primera vez

- **DOCUMENTACI√ìN**: Imagina que debes solicitar a alguien que realice un programa que cumpla con los requisitos que ves en pantalla. Piensa en todas las funciones y escr√≠belas en este documento.

- **CAMBIOS**: Entra a inspeccionar el c√≥digo y realiza cambios. Observa c√≥mo estos cambios afectan el comportamiento del personaje - ¬°o cambia los personajes para cambiar la historia!

- **EJECUCI√ìN**: Intenta resolver parte del desaf√≠o en un proyecto iniciado por t√≠. F√≠jate hasta d√≥nde llegas y qu√© te falta entender para poder lograr el desaf√≠o completo.

**¬°Hora de volver al equipo!**

Hemos trabajado mucho en el encuentro de hoy... y todav√≠a nos queda un poco m√°s.

J√∫ntense nuevamente y conversen sobre los ejercicios realizados. Enfoquen sus preguntas en ver c√≥mo resolvi√≥ cada miembro del equipo los requerimientos de cada desaf√≠o. No existe un solo camino para resolver un pedido, ¬øo s√≠?

Compartan pantalla, analicen en d√≥nde hicieron las cosas distinto.

---

![image](https://user-images.githubusercontent.com/72580574/214076320-14c4f6e3-3240-4176-ac0c-2cb44bd92f08.png)


---

**ATENCI√ìN: antes de seguir, hagan un check de tiempo. ¬øC√≥mo vienen? ¬øNecesitan apurarse? ¬øO resultaron ser unos genios de la organizaci√≥n?**

Retomamos el Ciclo de vida de la Producci√≥n de software que vimos en el encuentro pasado y que hoy vivimos en primera persona con el ejercicio de Scratch.

¬øHan podido identificar alguna de estas etapas en los ejercicios que realizaron en Scratch?

Si bien no estaban resolviendo los requerimientos de un cliente, de alguna manera intentaron descubrir qu√© se necesitaba resolver y c√≥mo lo iban a hacer.

Nota: ¬øRealizaron alguna secuencia de testing en la resoluci√≥n de los ejercicios anteriores?

---

## üìò MATERIAL DE LECTURA üìò

### CICLO DE PRODUCCI√ìN DE SOFTWARE: TESTING

Cuando el c√≥digo es peque√±o y no es complejo es relativamente sencillo hacer un peque√±o test para comprobar que est√© funcionando. Cuando somos desarrolladores a eso lo llamamos unit testing.

Si durante la resoluci√≥n de los desaf√≠os en Scratch, realizaron pruebas intermedias para comprobar que el c√≥digo estuviera actuando como ustedes lo hab√≠an imaginado, estuvieron realizando acciones de unit testing.

En programaci√≥n, una **prueba unitaria** o **test unitario** es una forma efectiva de comprobar el correcto funcionamiento de las unidades individuales m√°s peque√±as de los programas inform√°ticos. Por ejemplo, una funci√≥n o un procedimiento.

En el ciclo de vida de producci√≥n de software, ese tipo de testing se realiza durante la **etapa de development o desarrollo** y la realizan los equipos de desarrolladores.

### Etapa de testing:

Una vez que el c√≥digo ha sido chequeado por parte del equipo de desarrollo, se env√≠a al equipo de **Quality control** (**QC**) para que revisen si funciona. Aqu√≠ nos adentramos en el coraz√≥n del trabajo de un equipo de testing.

#### ¬øC√≥mo se prueba el software?

Se realiza un empaquetado para poder implementar el software en un ambiente especial de pruebas para garantizar la calidad. Las pruebas o el control de calidad garantizan que las soluciones implementadas superen el est√°ndar de calidad y rendimiento. Esto puede implicar repetir pruebas unitarias, la realizaci√≥n de pruebas de integraci√≥n y de extremo a extremo, verificaci√≥n/validaci√≥n e informes o identificaci√≥n de errores o defectos en la soluci√≥n de software.

Aqu√≠ el tester es protagonista, debe encontrar los fallos cometidos en la etapa o iteraci√≥n y reportarlos, para resolverlos antes de la siguiente etapa o iteraci√≥n. Su √©xito se medir√° en su capacidad de encontrar estos errores antes que el usuario.

*Pro tip*: El momento del testing es fundamental.

¬øNo nos crees? Lee en [este enlace](https://docs.google.com/document/d/1ES8wmk9tb5GugN8eKhbvLUyEit_ikaR0/edit?usp=sharing&ouid=107754327659263796384&rtpof=true&sd=true) los costos de los errores m√°s caros de la historia por falta de pruebas exhaustivas.

### ¬øCu√°ndo comienzan las pruebas de software en SDLC?

La mayor√≠a de la gente piensa en las pruebas de software como algo que sucede al final del proceso de desarrollo de software. Despu√©s de todo, ¬øqu√© podr√≠a ser m√°s l√≥gico que probar el producto que se acaba de crear?

En realidad, las pruebas de software deben comenzar mucho antes de que el producto terminado est√© listo para enviarse. De hecho, a menudo es mejor comenzar a probar temprano en el SDLC, cuando todav√≠a hay muchos cambios por hacer.

La primera fase del SDLC (strategy) incluye la recopilaci√≥n o an√°lisis de requisitos.

Aqu√≠ es cuando determina qu√© debe hacer el sistema y c√≥mo funcionar√°. Tambi√©n es cuando se identifican los posibles riesgos y problemas que deben abordarse.

Como todav√≠a no hay nada del producto desarrollado, es como ver los planos de una casa a punto de ser construida. Podemos anticipar algunos problemas antes de gastar dinero en construir, pero otros solamente los podremos ver una vez que se inicia el desarrollo del c√≥digo.
El dise√±o de las pruebas debe comenzar durante la recopilaci√≥n de requisitos para garantizar que el sistema funcione seg√∫n lo previsto y que no haya fallas importantes. Si se encuentran problemas en esta etapa inicial, a menudo se pueden solucionar antes de que se invierta demasiado tiempo y dinero en el desarrollo(1).


Una vez que se finaliza la documentaci√≥n de los requisitos, se procede al dise√±o (design) y desarrollo (development). Aqu√≠ es donde tiene lugar la escritura de c√≥digo real y el producto comienza a tomar forma. El c√≥digo debe probarse a medida que se escribe, para asegurarse de que funciona correctamente y cumpla con todos los requisitos.

En este punto, las pruebas no solo se preocupan por la funcionalidad; tambi√©n comienzan a abordar el rendimiento y la escalabilidad.
El producto debe poder manejar la carga esperada y ofrecer tiempos de respuesta aceptables. (¬øTe suena familiar que la p√°gina web de un concierto se "caiga" en las primeras horas de venta de entradas? Eso responde a la carga que puede sostener un proyecto de software)
A medida que avanza el desarrollo, se realizan pruebas m√°s detalladas sobre caracter√≠sticas y funciones espec√≠ficas. Las pruebas de integraci√≥n se realizan para asegurarse de que todas las piezas encajan correctamente, y las pruebas del sistema verifican que todo el producto funciona seg√∫n lo previsto.


**Todo el conocimiento que se gane en la etapa de an√°lisis de requerimientos, permite que los QA, o los testers si es un equipo peque√±o, puedan ya ir trabajando sobre el dise√±o de las pruebas. No es necesario esperar a que los desarrolladores entreguen porciones de software para comenzar a trabajar. Y muchas veces las preguntas de los testers ayudan a construir un c√≥digo m√°s eficiente y funcional ya que ponen foco en problemas que pueden ocurrir m√°s adelante y permiten que se solucionen desde el momento del dise√±o.**

(1)No olvidemos que las metodolog√≠as √°giles de desarrollo nos permiten entregar MPVs (o productos m√≠nimos viables, por sus siglas en ingl√©s). Estos MVPs muchas veces son tan solo una maqueta del sistema que estamos desarrollando y ya nos permiten poder evaluar si lo que estamos construyendo avanza en la direcci√≥n correcta o no.



---


## üìò MATERIAL DE LECTURA üìò


### INTRODUCCI√ìN AL LENGUAJE UNIFICADO DE MODELADO (UML)


*¬°Pro tip alert!* Esta introducci√≥n a UML es tan solo eso. Para poder utilizarlo correctamente se necesita ir m√°s profundo y estudiar. Si es de tu inter√©s, no dudes en hacer una r√°pida b√∫squeda en Google para aprender m√°s sobre c√≥mo y cu√°ndo usarlo.

### Contexto

Uno de los mayores desaf√≠os en el dise√±o y producci√≥n de software es poder entenderse entre equipos de distintas disciplinas. El cliente pide requerimientos en lenguaje cotidiano, los ingenieros lo pasan a lenguaje t√©cnico y los testers deben poder entender ambos lenguajes para poder controlar que lo que se pidi√≥ est√© realmente presente en el producto o proyecto que se va a entregar.

Una de las estrategias que se utilizan para diagramar los requerimientos es el uso de esquemas realizados en UML o unified modelling language - lenguaje unificado de modelado. Cuenta la leyenda que en el a√±o 1997 un grupo de ingenieros entusiastas, cansados de intentar leer dibujos en servilletas, decidieron poner fin al castigo y armaron este sistema de s√≠mbolos y c√≥digos que es independiente de los lenguajes de programaci√≥n. ¬øQu√© significa eso? Que no importa el nivel de requerimientos o la dificultad del lenguaje a utilizar, las funcionalidades y casos de uso se pueden representar utilizando UML.

Como UML es un lenguaje y no una metodolog√≠a, se puede utilizar sin necesidad de tener gu√≠as o ceremonias(2).

(2) En el caso de las metodolog√≠as √°giles se llaman as√≠ porque son metodolog√≠as y requieren que aprendamos ceremonias, pasos y procesos para llevarlas a cabo correctamente y que nos brinden los mayores beneficios al ser implementadas. Con solamente saber que las metodolog√≠as √°giles existen no alcanza.


### ¬øNECESITAS UN EJEMPLO? 

El director de un Centro de educaci√≥n F√≠sica, los ha contratado para desarrollar un sistema, pero solo cuenta con una gr√°fica del dise√±o preliminar:

![image](https://user-images.githubusercontent.com/72580574/214077872-5c2d6f20-863d-4a62-8b87-adc6172c9ed1.png)

Este dise√±o utiliza UML para explicar las relaciones entre los datos, los roles, las transacciones y la direcci√≥n de flujo de datos. A continuaci√≥n tienen una ayuda memoria para poder analizar en profundidad el diagrama.

![image](https://user-images.githubusercontent.com/72580574/214078006-e4d67a40-b7c2-4ee4-84b2-763ee77a86e0.png)

---

## <img src="https://img.icons8.com/emoji/48/null/writing-hand.png"/>  MANOS A LA OBRA

##  ‚ñ∂Ô∏è  EJERCICIO ¬∑ 4

1. Analiza en forma individual el gr√°fico de requerimientos. Considera el cuadro con el ayuda-memoria de UML.

2. Describe los requerimientos del sistema en formato de lista completa y siguiendo las secuencias completas. Controla que no falte ning√∫n dato ni acciones.

![image](https://user-images.githubusercontent.com/72580574/214078501-ddede79c-5aa8-4af2-b412-0fefc6e389f6.png)


![image](https://user-images.githubusercontent.com/72580574/214078690-560c3f51-6cb9-4010-a233-b7287aca7932.png)


---

## <img src="https://img.icons8.com/material-two-tone/40/null/wall-clock.png"/> HORA DE CERRAR

### Consolidaci√≥n de cierre:

T√≥mense estos √∫ltimos 25 minutos del encuentro de hoy para comparar los resultados en el ejercicio que realizaron reci√©n.

- Uno de ustedes puede compartir pantalla mostrando su resoluci√≥n y el resto puede aportar:

1. Lo que hicieron igual

2. Lo que resolvieron distinto

3. Evaluar si alguna versi√≥n es superadora y tomar nota de por qu√©. ¬øQu√© elementos de esa versi√≥n nos llaman la atenci√≥n por su claridad?  ¬øSer√° la forma de comunicarlos?

4. ¬øAlg√∫n integrante del equipo de hoy ten√≠a ya experiencia con este lenguaje y puede hacer aportes que le sirvan al resto?

¬°Hora de regresar a la sala general!

No olvides agradecer a tus compa√±er@s de hoy. Recuerda sus nombres ya que posiblemente los vuelvas a ver pronto. Y si deseas valorar el aporte de alguien en particular, ¬°entr√©gale un pulso!

---
---

## :star2: [BASES DE PROGRAMACION](https://docs.google.com/document/d/1P51kCox48lHC13M__HAKENGVY9Akgvfn/edit)

## <img src="https://img.icons8.com/bubbles/50/null/console.png"/> ¬øQu√© es la Programaci√≥n?

En inform√°tica el t√©rmino programaci√≥n se refiere a la acci√≥n de crear programas y programar es la serie de instrucciones, que le vamos a dar a nuestra computadora para lograr que nuestro programa funcione.

Las partes que componen a nuestro programa son el lenguaje de programaci√≥n y los algoritmos. 

## <img src="https://img.icons8.com/bubbles/50/null/console.png"/> 1 - ¬øQu√© es un lenguaje de programaci√≥n?

Es un lenguaje formal que, mediante una serie de instrucciones, le permite a un programador escribir un conjunto de √≥rdenes, acciones consecutivas, datos y algoritmos para, de esa forma, resolver problemas.

Las instrucciones que sigue la computadora para la creaci√≥n de programas est√°n escritas en un lenguaje de programaci√≥n y luego son traducidas a un lenguaje de m√°quina que puede ser interpretado y ejecutado por el hardware del equipo.

## <img src="https://img.icons8.com/bubbles/50/null/console.png"/> 2 - ¬øQu√© es un algoritmo?

Las instrucciones que le vamos a dar a nuestro programa, se conocen como algoritmos. Un algoritmo es un m√©todo para darle instrucciones a nuestro programa y resolver un problema.

Este consiste en la realizaci√≥n de un conjunto de pasos l√≥gicamente ordenados tal que, partiendo de la informaci√≥n que le demos, permite obtener ciertos resultados que conforman la soluci√≥n del problema.  

Los algoritmos son independientes tanto del lenguaje de programaci√≥n en que se expresan como de la computadora que los ejecuta. En cada problema el algoritmo se puede expresar en un lenguaje diferente de programaci√≥n y ejecutarse en una computadora distinta; sin embargo, el algoritmo ser√° siempre el mismo. As√≠, por ejemplo, en una analog√≠a con la vida diaria, una receta de un plato de cocina se puede expresar en espa√±ol, ingl√©s o franc√©s, pero cualquiera que sea el lenguaje, los pasos para la elaboraci√≥n del plato se realizan sin importar el idioma del cocinero.

Los algoritmos son m√°s importantes que los lenguajes de programaci√≥n o las computadoras. Un lenguaje de programaci√≥n es s√≥lo un medio para expresar un algoritmo y una computadora es solo un procesador para ejecutarlo. Tanto el lenguaje de programaci√≥n como la computadora son los medios para obtener un fin: conseguir que el algoritmo se ejecute y se efect√∫e el proceso correspondiente.

El programador debe constantemente resolver problemas de manera algor√≠tmica, lo que significa plantear el problema de forma tal que queden indicados los pasos necesarios para obtener los resultados pedidos, a partir de los datos conocidos. Lo anterior implica que un algoritmo b√°sicamente consta de tres elementos: Datos de Entrada o Informaci√≥n de entrada, Procesos y la Informaci√≥n de Salida.

![image](https://user-images.githubusercontent.com/72580574/214079578-91aa4176-8000-40b2-a547-0162f1cb9715.png)


## <img src="https://img.icons8.com/bubbles/50/null/console.png"/>  Programa

¬øD√≥nde se van a ver reflejados los lenguajes de programaci√≥n y los algoritmos? En nuestro programa.

Un programa no es m√°s que una serie de algoritmos escritos en alg√∫n lenguaje de programaci√≥n de computadoras. Un programa es, por lo tanto, un conjunto de instrucciones ‚Äî√≥rdenes dadas a la computadora‚Äî que producir√°n la ejecuci√≥n de una determinada tarea. En esencia, un programa es un medio para conseguir un fin. El fin ser√° probablemente definido como la informaci√≥n necesaria para solucionar un problema.

### Especificaciones de un programa

Tras la decisi√≥n de desarrollar un programa, el programador debe establecer el conjunto de especificaciones que debe contener el programa: entrada, salida y algoritmos de resoluci√≥n, que incluir√°n las t√©cnicas para obtener las salidas a partir de las entradas.
Un programa puede ser lineal (secuencial) o no lineal. Un programa es lineal si las instrucciones (acciones) se ejecutan secuencialmente como los ejercicios propuestos en esta gu√≠a, es decir, sin bifurcaciones, decisi√≥n ni comparaciones.

![image](https://user-images.githubusercontent.com/72580574/214080017-ce3973b1-d48b-420f-b3b7-07321b94ca70.png)


## <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Codificaci√≥n

Una vez que tenemos las especificaciones de un programa pasaremos a la codificaci√≥n del programa. La codificaci√≥n es la operaci√≥n de escribir la soluci√≥n del problema (de acuerdo a la l√≥gica del pseudoc√≥digo), en una serie de instrucciones detalladas, en un c√≥digo reconocible por la computadora. La serie de instrucciones detalladas se conoce como c√≥digo fuente, el cual se escribe en un lenguaje de programaci√≥n o lenguaje de alto nivel.

### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> ¬øC√≥mo deben escribirse los algoritmos/programas?

Ya sabemos que es un programa, el dise√±o de un programa, las especificaciones de un programa y su codificaci√≥n. Ahora vamos a ver como es la escritura de estos algoritmos / programas.

Un algoritmo consta de dos componentes: una cabecera de programa y un bloque algoritmo. La cabecera de programa es una acci√≥n simple que comienza con la palabra ‚Äúalgoritmo‚Äù. Esta palabra estar√° seguida por el nombre asignado al programa completo.
El bloque algoritmo es el resto del programa y consta de dos componentes o secciones: las acciones de declaraci√≥n y las acciones ejecutables.

Las declaraciones definen o declaran las variables que tengan nombres. Las acciones ejecutables son las acciones que posteriormente deber√° realizar la computaci√≥n cuando el algoritmo convertido en programa se ejecute.

#### Cabecera del programa

Todos los algoritmos y programas deben comenzar con una cabecera en la que se exprese el identificador o nombre correspondiente con la palabra reservada que se√±ale el lenguaje. 

```
Algoritmo sin_titulo
 	<Acciones>
FinAlgoritmo
```

Donde la palabra sin t√≠tulo debe ser reemplazada por el nombre del algoritmo. Esto se podr√≠a ver as√≠:

![image](https://user-images.githubusercontent.com/72580574/214080311-e77b621d-4490-485a-a344-93166be394a6.png)

### ¬øQu√© elementos posee un programa?

Los elementos de un programa, son b√°sicamente, los componentes que conforman las instrucciones previamente mencionadas, para crear nuestro programa y resolver sus problemas. Estos elementos siempre estar√°n dentro de un algoritmo.

Los elementos de un programa son: identificadores, variables, constantes, operadores, palabras reservadas.

###  <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Identificadores

Un identificador es un conjunto de caracteres alfanum√©ricos de cualquier longitud que sirve para identificar las entidades del programa (nombre del programa, nombres de variables, constantes, subprogramas, etc.). 

En la mayor√≠a de los lenguajes de programaci√≥n los identificadores deben constar s√≥lo de letras, n√∫meros y/o gui√≥n bajo (_), comenzando siempre con una letra y se suelen escribir siempre en min√∫sculas. Estos tampoco pueden contar de tildes, ni de la letra √ë, ya que generar√≠a errores.

Otra cosa que es s√∫per importante a la hora de pensar identificadores, es poner nombres claros, por ejemplo, si queremos tener una frase, que el identificador sea frase o si queremos una suma, le pondremos suma.


### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Variables y Constantes

Los programas de computadora necesitan informaci√≥n para la resoluci√≥n de problemas. Est√° informaci√≥n puede ser un n√∫mero, un nombre, etc. Para que podamos guardar esta informaci√≥n en alg√∫n lugar y que no est√© ‚Äúsuelta‚Äù, para no perderla o poder acceder a ella cuando lo necesitemos es crucial que guardemos  la informaci√≥n en algo llamado, variables y constantes. 

Las variables y constantes vendr√≠an a ser como peque√±as cajas, que guardan algo en su interior, en este caso informaci√≥n. Estas, van a contar como previamente hab√≠amos mencionado, con un identificador, un nombre que facilitar√° distinguir unas de otras y nos ayudar√° a saber que variable o constante es la contiene la informaci√≥n que necesitamos.

Dentro de toda la informaci√≥n que vamos a manejar, a veces, necesitaremos informaci√≥n que no cambie. Tales valores son constantes. De igual forma, existen otros valores que s√≠ necesitaremos que cambien durante la ejecuci√≥n del programa; esas van a ser nuestras variables.  

### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Tipos de datos en general (1)

Las variables y constantes como previamente hab√≠amos mencionado, van a guardar informaci√≥n dependiendo del tipo de dato que le digamos que guarde esa variable. Por ejemplo, si digo que mi variable va a guardar n√∫meros enteros, significa que el tipo de dato de esa variable es entero.

Los tipos de datos que podemos usar son:

‚úì **Entero**: solo n√∫meros enteros.

‚úì **Real**: n√∫meros con cifras decimales. Para separar decimales se utiliza el punto. Ejemplo: 3.14

‚úì **Car√°cter**: cuando queremos guardar un car√°cter. Los Caracteres se encierran entre comillas simples. un car√°cter (unidimensional): ‚Äòa‚Äô, 'A'.

‚úì **L√≥gico**: cuando necesitamos guardar una expresi√≥n l√≥gica (verdadero o falso)

‚úì **Cadena**: cuando queremos guardar cadenas de caracteres. Las Cadenas se encierran entre comillas dobles. una cadena (multidimensional): ‚Äúesto es una cadena‚Äù, "hola mundo" 


(1)  Los tipos de datos dependen del lenguaje utilizado para programar. Aqu√≠ s√≥lo hablaremos de generalidades


### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> ¬øC√≥mo se crean las Variables?

La definici√≥n de variables es relativa de acuerdo al lenguaje de programaci√≥n que se utiliza.  A continuaci√≥n veremos una forma gen√©rica de hacerlo.

A la hora de crear nuestra variable, vamos a tener que darle un identificador, por lo que usaremos las reglas vistas en el apartado de identificadores, y el tipo de dato que necesitamos que guarde.  
Despu√©s de la palabra Definir, va el nombre de la variable y por √∫ltimo el tipo de dato de la variable. Normalmente los identificadores de las variables y de las constantes con nombre deben ser declaradas en los programas antes de ser utilizadas. Entonces, la sintaxis de la declaraci√≥n de una variable suele ser:

```
Definir <nombre_variable> como <tipo_de_dato>
```

### Ejemplo:

```
Definir varNumero Como Entero
```

**varNumero** se convierte en una variable de tipo entero.


###<img src="https://img.icons8.com/bubbles/50/null/console.png"/>  Tipos de instrucciones

Las instrucciones ‚Äîacciones‚Äî b√°sicas que se pueden implementar de modo general en un algoritmo y que esencialmente soportan todos los lenguajes son las siguientes:

#### Instrucciones de inicio/fin

Son utilizadas para delimitar bloques de c√≥digo. Por ejemplo, Algoritmo y FinAlgoritmo.

#### Instrucciones de escritura o salida

Se utilizan para escribir o mostrar mensajes o contenidos de las variables en un dispositivo de salida. 

La salida puede aparecer en un dispositivo de salida (pantalla, impresora, etc.). La operaci√≥n de salida se denomina escritura (escribir). 

##### Ejemplo

![image](https://user-images.githubusercontent.com/72580574/214081201-ee506253-527d-482c-be2a-c7b58e2c3aae.png)


En este ejemplo de escribir, vemos que nuestro primer escribir muestra un mensaje o cadena, que va entre comillas dobles, despu√©s nuestro segundo escribir muestra el resultado de una suma de dos n√∫meros y nuestro √∫ltimo escribir, muestra el valor de una variable de tipo entero a la que se le asign√≥ un valor previo.

- **Instrucciones de lectura**: Para que los c√°lculos que realizan las computadoras sean √∫tiles requieren de la entrada de los datos necesarios para ejecutar las operaciones que posteriormente se convertir√°n en resultados, es decir, salida.
- 
Las operaciones de entrada permiten leer datos de un dispositivo de entrada y asignarlos a determinadas variables.

Esta entrada se conoce como operaci√≥n de lectura (leer). Los datos de entrada se introducen al procesador mediante dispositivos de entrada (teclado).

#### Ejemplo

![image](https://user-images.githubusercontent.com/72580574/214081339-3c9108e0-262c-4e98-b41b-5d45b1050fa2.png)

En este ejemplo definimos una variable de tipo entero llamada num y le asignamos un valor a trav√©s de la instrucci√≥n Leer.


#### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> ¬øC√≥mo asignamos valores a las variables?

La instrucci√≥n de asignaci√≥n permite almacenar un valor en una variable (previamente definida). Esta es nuestra manera de guardar informaci√≥n en una variable, para utilizar ese valor en otro momento.  Se puede realizar con el signo igual: 

```
<variable> = <expresi√≥n> 
```

Donde expresi√≥n es igual a una expresi√≥n matem√°tica o l√≥gica, a una variable o constante.
Al ejecutarse la asignaci√≥n, primero se eval√∫a la expresi√≥n de la derecha y luego se asigna el resultado a la variable de la izquierda. El tipo de la variable y el de la expresi√≥n deben coincidir.

##### Ejemplo

![image](https://user-images.githubusercontent.com/72580574/214081511-b6a69f45-01b9-42bd-a797-e93c28ecda3d.png)


En este ejemplo estamos definiendo una variable como entero y despu√©s asign√°ndole un valor, en este caso el n√∫mero 4.

### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Operadores

Este pseudolenguaje dispone de un conjunto b√°sico de operadores que pueden ser utilizados para la construcci√≥n de expresiones m√°s o menos complejas.

#### Operadores Algebraicos

Los operadores algebraicos o tambi√©n conocidos como operadores aritm√©ticos. Realizan operaciones aritm√©ticas b√°sicas: suma, resta, multiplicaci√≥n, divisi√≥n, potenciaci√≥n y m√≥dulo para datos de tipo num√©rico tanto enteros como reales. Estas operaciones son binarias porque admiten dos operandos.

![image](https://user-images.githubusercontent.com/72580574/214081645-9b719519-8d36-45a6-902c-57a2c30bd8b3.png)


### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Estructura de Control

Las Estructuras de Control determinan el orden en que deben ejecutarse las instrucciones de un algoritmo, es decir, si ser√°n recorridas una despu√©s de la otra (estructuras secuenciales), si habr√° que tomar decisiones sobre si ejecutar o no alguna acci√≥n (estructuras selectivas o de decisi√≥n) o si habr√° que realizar repeticiones (estructuras repetitivas). Esto significa que una estructura de control permite que se realicen unas instrucciones y omitir otras, de acuerdo a la evaluaci√≥n de una condici√≥n.
Esto hace que las estructuras de control se puedan dividir en tres:

- **Estructuras secuenciales**: Es la estructura en donde una acci√≥n (instrucci√≥n) sigue a otra de manera secuencial.  Las tareas se dan de tal forma que la salida de una es la entrada de la que sigue y as√≠ en lo sucesivo hasta cumplir con todo el proceso. Esta estructura de control es la m√°s simple, permite que las instrucciones que la constituyen se ejecuten una tras otra en el orden en que se listan.

![image](https://user-images.githubusercontent.com/72580574/214081755-d5a27975-15be-4e4d-889c-5f06bf0c3f24.png)


- **Estructuras selectivas o de decisi√≥n**: Estas estructuras de control son de gran utilidad para cuando el algoritmo a desarrollar requiera una descripci√≥n m√°s complicada que una lista sencilla de instrucciones. Este es el caso cuando existe un n√∫mero de posibles alternativas que resultan de la evaluaci√≥n de una determinada condici√≥n. Este tipo de estructuras son utilizadas para tomar decisiones l√≥gicas, es por esto que tambi√©n se denominan estructuras de decisi√≥n o selectivas.
- 
En estas estructuras, se realiza una evaluaci√≥n de una condici√≥n y de acuerdo al resultado, el algoritmo realiza una determinada acci√≥n. Las condiciones son especificadas utilizando expresiones l√≥gicas.

Una estructura selectiva, con varias condiciones, ser√≠a el ejemplo que usamos en la primera parte de Cocinar un Huevo. Las preguntas ser√≠an las condiciones a evaluar y de acuerdo a ese resultado realiza una o u otra acci√≥n.

![image](https://user-images.githubusercontent.com/72580574/214081916-9fd035b7-d078-4197-8015-2275d91e5dd4.png)

- **Estructuras repetitivas**: Son aquellas que repiten las acciones determinada cantidad de veces en funci√≥n de una condici√≥n o en funci√≥n a una cantidad establecida por el programador. 

### ¬øQu√© es una condici√≥n?

En programaci√≥n, una condici√≥n es toda sentencia de la cual se puede determinar su verdad (true) o falsedad (false). En su gran mayor√≠a, son comparaciones. Por ejemplo, 4 > 5, esta sentencia es una condici√≥n porque tiene resultado verdadero o falso, en este caso falso porque 4 no es mayor a 5. En cambio, la siguiente sentencia, Escribir ‚ÄúEggEducacion‚Äù, no es condici√≥n puesto que no hay para comparar, no se puede determinar verdad o falsedad.

Por lo que una condici√≥n sirve para discernir entre una opci√≥n u otra, y en el proceso mental normalmente se manifiesta con un ‚ÄúSi‚Äù; por ejemplo: Si (va a llover), coge el paraguas.

Para determinar condiciones, precisamos utilizar Operadores.

#### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> ¬øQu√© son los operadores?

Las condiciones que usaremos en las estructuras selectivas y el resto de nuestras estructuras de control se realizan con la ayuda de los operadores relacionales y l√≥gicos.

Los operadores relacionales son s√≠mbolos que se usan para comparar dos valores. Si el resultado de la comparaci√≥n es correcto la expresi√≥n considerada es verdadera, en caso contrario es falsa. 

![image](https://user-images.githubusercontent.com/72580574/214082124-e5c2e0b4-b457-45b6-b4ed-3052613cbdbf.png)


#### Operadores L√≥gicos

Estos se utilizan cuando necesitamos las expresiones l√≥gicas con m√∫ltiples variantes y nos proporcionan un resultado a partir de que se cumpla o no una cierta condici√≥n, estos producen un resultado l√≥gico, y sus operadores son tambi√©n valores l√≥gicos o asimilables a ellos.

![image](https://user-images.githubusercontent.com/72580574/214082237-40491e80-05a0-47c5-bab9-64f89bd18f0b.png)

- **Operador Y**: Devuelve un valor l√≥gico verdadero si ambas expresiones son verdaderas. En caso contrario el resultado es falso.
 
- **Operador O**: Este operador devuelve verdadero si alguna de las expresiones es verdadera. En caso contrario devuelve ‚Äúfalso‚Äù.

- **Operador NO**: Este operador cambia la devoluci√≥n de una expresi√≥n, al caso contrario. Si es verdadero lo hace falso y si es falso lo hace verdadero.

A la hora de trabajar con operadores l√≥gicos, para saber si una expresi√≥n l√≥gica nos devuelve como resultado Verdadero o Falso, debemos observar la siguiente tabla de la verdad:

![image](https://user-images.githubusercontent.com/72580574/214082451-626890a9-9d40-478d-994e-5f980221c0bf.png)


### Ejemplos:

Vamos a mostrar ejemplos de condiciones tanto con operadores relacionales, como con l√≥gicos:

```
x==y, significa ‚Äúsi x es igual a y‚Äù
x>y, significa ‚Äúsi x es mayor que y‚Äù
x<y, significa ‚Äúsi x es menor que y‚Äù
x!=y, significa ‚Äúsi x es distinto de y‚Äù
(x==j) Y (x==z), significa ‚Äúsi x es igual a j Y x igual a z‚Äù
(x==y) O (x==z), significa ‚Äúsi x es igual a j O x igual a z‚Äù
```

###  <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Estructuras selectivas

Entendemos que las estructuras selectivas son utilizadas para tomar decisiones l√≥gicas, es por esto que tambi√©n se denominan estructuras de decisi√≥n o selectivas. Pero, ¬øcu√°les son las estructuras selectivas? 

Las estructuras selectivas/alternativas pueden ser:

¬∑ **Simples** (**Si** / **IF**)

¬∑ **Doble** (**Si- SiNo** / **IF - ELSE**)

¬∑ **M√∫ltiples**: (**Seg√∫n ‚Äì Si Anidado** / **IF-ELSE IF- ELSE**) 

### Condici√≥n Simple

La estructura alternativa simple si-entonces lleva a cabo una acci√≥n siempre y cuando se cumpla una determinada condici√≥n.

![image](https://user-images.githubusercontent.com/72580574/214082977-d8860417-4985-4547-9a48-ec00a558e079.png)

La selecci√≥n si-entonces eval√∫a la condici√≥n y luego:

¬∑ Si la condici√≥n es verdadera, ejecuta el bloque de acciones

¬∑ Si la condici√≥n es falsa, no ejecuta otra opci√≥n.


#### Ejemplo:

![image](https://user-images.githubusercontent.com/72580574/214083095-86e6dce1-a781-427f-8974-4a72ec7e4296.png)

Si fuera cocinar un huevo, tenemos solo la opci√≥n de fre√≠rlo y si no lo queremos frito, se va servir crudo en el plato. Esto es una Condici√≥n Simple.

### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Condici√≥n Doble

La estructura anterior es muy limitada y normalmente se necesitar√° una estructura que permita elegir entre dos opciones o alternativas posibles, en funci√≥n del cumplimiento o no de una determinada condici√≥n. Si la condici√≥n es verdadera, se ejecuta la acci√≥n S1 y, si es falsa, se ejecuta la acci√≥n S2.

![image](https://user-images.githubusercontent.com/72580574/214083196-19bfe77b-c098-4891-9f7c-3a09adb9de9c.png)

La selecci√≥n si-entonces-sino eval√∫a la condici√≥n y luego:

¬∑ Si la condici√≥n es verdadera, ejecuta el bloque de acciones

¬∑ Si la condici√≥n es falsa, ejecuta el bloque de acciones 2.


![image](https://user-images.githubusercontent.com/72580574/214083283-3f74fc74-d959-4108-8d1e-bb688c937c88.png)


En este caso, si fuera cocinar un huevo, tenemos opci√≥n de fre√≠rlo y si no lo queremos frito, tendremos la opci√≥n de hervirlo. Esto es una Condici√≥n Doble.

### <img src="https://img.icons8.com/bubbles/50/null/console.png"/> Condici√≥n M√∫ltiple

Muchas veces vamos a tener m√°s de dos alternativas para elegir, o una variable que puede tomar varios valores. Para solucionar esto, usamos la condici√≥n m√∫ltiple. En esta estructura, se eval√∫a una condici√≥n o expresi√≥n que puede tomar n valores. Seg√∫n el valor que la expresi√≥n tenga en cada momento se ejecutan las acciones correspondientes al valor.

La estructura de decisi√≥n m√∫ltiple evaluar√° una expresi√≥n que podr√° tomar n valores distintos, 1, 2, 3, 4, ..., n. Seg√∫n el valor que elija en la condici√≥n, se realizar√° una de las n acciones, o lo que es igual, el flujo del algoritmo seguir√° un determinado camino entre los n posibles. Por ejemplo, si tenemos un sistema de notas, donde 6 es desaprobado, 7 es aprobado, 9 es sobresaliente y 10 es excelente. Al tener un valor que puede dar distintas alternativas, usamos la condici√≥n m√∫ltiple.

![image](https://user-images.githubusercontent.com/72580574/214083393-0c7c1c63-61ff-44fe-a1fe-76b2d2d17aea.png)

Este problema, se podr√≠a resolver por estructuras alternativas simples o dobles, anidadas o en cascada; sin embargo, este m√©todo si el n√∫mero de alternativas es grande puede plantear serios problemas de escritura del algoritmo y naturalmente de legibilidad.


---

